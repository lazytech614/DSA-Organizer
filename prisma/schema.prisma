generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Question {
  id          String     @id @default(cuid())
  title       String
  topics      String[]
  urls        String[]
  difficulty  Difficulty
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  courses     Course[]   @relation("CourseQuestions")
  solvedBy    UserQuestionSolved[] 
  
  @@map("questions")
}

model User {
  id          String   @id @default(cuid())
  clerkId     String   @unique
  name        String?
  email       String?  @unique
  courses     Course[]
  solvedQuestions UserQuestionSolved[] 
  bookmarkedQuestions String[] @default([])

  // ✅ Subscription fields
  subscriptionType    SubscriptionType @default(FREE)
  subscriptionStatus  SubscriptionStatus @default(ACTIVE)
  subscriptionStart   DateTime?
  subscriptionEnd     DateTime?
  stripeCustomerId    String?
  stripeSubscriptionId String?

  // ✅ Usage tracking for limits
  totalCoursesCreated Int      @default(0)

  // ✅ Platform integration relations (ADDED THESE)
  linkedPlatforms     UserPlatform[]
  platformSyncs       PlatformSync[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("users")
}

model Course {
  id          String     @id @default(cuid())
  title       String
  isDefault   Boolean    @default(false)
  user        User?      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String?
  questions   Question[] @relation("CourseQuestions")

  // ✅ Usage tracking
  questionCount Int      @default(0) // Cached count for performance

  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@map("courses")
}

model UserQuestionSolved {
  id          String   @id @default(cuid())
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  question    Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  questionId  String
  solvedAt    DateTime @default(now())
  
  @@unique([userId, questionId]) 
  @@map("user_questions_solved")
}

model SubscriptionPlan {
  id                String           @id @default(cuid())
  type              SubscriptionType @unique
  name              String
  description       String?
  maxCourses        Int              // -1 for unlimited
  maxQuestionsPerCourse Int          // -1 for unlimited
  monthlyPrice      Decimal?
  yearlyPrice       Decimal?
  stripePriceId     String?          // Stripe price ID
  features          String[]         // Array of feature names
  isActive          Boolean          @default(true)
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  @@map("subscription_plans")
}

model UserPlatform {
  id        String   @id @default(cuid())
  userId    String
  platform  Platform
  username  String
  isActive  Boolean  @default(true)
  lastSync  DateTime @default(now())
  
  // Platform-specific data
  stats     Json?    // Store normalized stats
  
  user      User     @relation(fields: [userId], references: [id])
  
  @@unique([userId, platform])
  @@map("user_platforms")
}

model PlatformSync {
  id          String   @id @default(cuid())
  userId      String
  platform    Platform
  syncedAt    DateTime @default(now())
  status      SyncStatus
  data        Json?
  errorMsg    String?
  
  user        User     @relation(fields: [userId], references: [id])

  @@map("platform_syncs")
}

enum Difficulty {
  EASY
  MEDIUM
  HARD
}

enum SubscriptionType {
  FREE
  PRO
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
  PAST_DUE
}


enum Platform {
  LEETCODE
  GEEKSFORGEEKS
  CODEFORCES
  CODECHEF
  HACKERRANK
  ATCODER
}

enum SyncStatus {
  SUCCESS
  FAILED
  PENDING
}